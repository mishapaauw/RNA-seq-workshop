[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to the RNA-seq workshop of the bioDSC. This workshop will introduce you to the basics of gene expression analysis using RNA-Seq. It is going to be fun and empowering! You will discover how the total RNA pool of an organism is converted to short sequences called “reads” that can in turn be used to get insights into gene expression. Through careful experimental design, this gene expression information can answer research questions and offer biological insights.\nThe workshop consists of two core parts:\nThe materials on this website are meant to be discussed in two four-hour trainer-led workshop sessions. However, it should also be possible to follow the materials on your own, at your own pace. Regardless of how you go through the materials, we hope that you will learn something useful!"
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Welcome",
    "section": "Learning objectives",
    "text": "Learning objectives\nAfter this workshop, you should be able to:\n\nIdentify good practices when designing a RNA-Seq experiment\nAssess the quality of RNA-seq sequencing data (“reads”) using the command-line instructions\nAlign RNA-seq reads to a reference genome using a splice-aware aligner (e.g. STAR).\nGenerate a count matrix from the RNA-seq data alignment\nPerform a QC of your experiment through Principal Component Analysis (PCA) and sample clustering.\nExecute a differential gene expression analysis using R and the DESeq2 package.\nBe able to create key plots: volcano plot, heatmap and clustering of differentially expressed genes."
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Welcome",
    "section": "Schedule",
    "text": "Schedule\nFor the March 2026 beta-test run of this workshop, this is the schedule:\n\n\n\n\n\n\n\n\n\nDate\nTime\nLocation\nTopics\n\n\n\n\n02-03-2026\n13:00-17:00\nAmsterdam Sciencepark, B0.209\nExperimental considarations and read mapping\n\n\n04-03-2026\n13:00-17:00\nAmsterdam Sciencepark, B0.208\nDifferential gene expression and enrichment analysis"
  },
  {
    "objectID": "index.html#maintainers",
    "href": "index.html#maintainers",
    "title": "Welcome",
    "section": "Maintainers",
    "text": "Maintainers\nCurrent maintainers of this workshop page are members of the bioDSC (University of Amsterdam)."
  },
  {
    "objectID": "index.html#credits",
    "href": "index.html#credits",
    "title": "Welcome",
    "section": "Credits",
    "text": "Credits\nThis workshop is in part based on other teaching materials available online. The primary source is the RNA-seq lesson designed by the Science Park Study Group, which in turn was based on Harvard Chan Bioinformatics Core (HBC) RNA-seq materials. Both are open acces materials distributed under a CC BY 4.0 license."
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html",
    "href": "episodes/05-pathway-enrichment.html",
    "title": "Enrichment analysis",
    "section": "",
    "text": "In the previous episode, we ended up with a list of differentially expressed genes. We could examine this list manually and look for our favorite genes of interest. However, the power of RNA-seq is that we can move beyond a simple analysis of a few genes and start to understand which processes or pathways are involved in the response to your treatments. To do this, we will use overrepresentation analysis (ORA) of Gene Ontology (GO) terms.",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html#what-is-a-go-term-exactly",
    "href": "episodes/05-pathway-enrichment.html#what-is-a-go-term-exactly",
    "title": "Enrichment analysis",
    "section": "What is a GO term exactly?",
    "text": "What is a GO term exactly?\nGO terms offer a standardized way of describing gene functions and the biological processes they participate in. For example, a GO term could be: nucleotide binding or response to biotic stress. GO terms come in three categories:\n\nBiological Process (BP)\nMolecular Function (MF)\nCellular Component (CC)",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html#what-is-an-overrepresentation-analysis-exactly",
    "href": "episodes/05-pathway-enrichment.html#what-is-an-overrepresentation-analysis-exactly",
    "title": "Enrichment analysis",
    "section": "What is an overrepresentation analysis exactly?",
    "text": "What is an overrepresentation analysis exactly?\nIn the R package that we will use, ORA uses a hypergeometric test to determine whether a particular GO term is enriched in your list of genes. Conceptually, it answers the following question:\n\nGiven my background list of genes, are genes annotated to this GO term observed more often in my input gene list than expected by chance?\n\nThe background list of genes, sometimes called the ‘universe’ in ORA jargon, is important. Naively, one could decide to use all genes present in annotation of your organism as universe. However, the universe is defined as all the genes that were elegible to be tested for differential expression. For an RNA-seq experiment, this means that genes that were not detected in any of your samples should be removed from the background universe for ORA.",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html#lets-get-started",
    "href": "episodes/05-pathway-enrichment.html#lets-get-started",
    "title": "Enrichment analysis",
    "section": "Let’s get started",
    "text": "Let’s get started\nIn case you continued directly from the previous episode, you will only need to load a few more packages. clusterProfiler is the main package for enrichment analysis in R, extensively documented here. org.At.tair.db is a database containing functional annotation for Arabidopsis thaliana (At). Functional annotations are available for several model organisms such as Homo sapiens (org.Hs.tair.db), see Bioconductor for all available organisms.\n\n\n\nR\n\nlibrary(clusterProfiler)\nlibrary(org.At.tair.db)\nlibrary(enrichplot)\n\n\nIn case you didn’t manage to finish the previous episode, or you’re starting here for other reasons, you can run the following code to get back to the starting point of this episode by running:\n\n\n\nShow the code to get to the starting point of this episode\n\nR\n\nset.seed(1992)\n\n# Load packages\nlibrary(DESeq2)\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(clusterProfiler)\nlibrary(org.At.tair.db)\nlibrary(enrichplot)\n\n# Read the data\nraw_counts &lt;- read.csv(\"data/GLDS38_raw_counts.csv\", header = T, stringsAsFactors = F) \nraw_counts &lt;- raw_counts %&gt;% column_to_rownames(\"gene\") \nmetadata &lt;- read.csv(\"data/samples_to_condition.csv\", header = T)\n\n# Generate DDS object and run DESeq function:\ndds &lt;- DESeqDataSetFromMatrix(countData = raw_counts, \n                              colData = metadata, \n                              design = ~ condition)\n\ndds &lt;- DESeq(dds)\n\n# Run DEG analysis\nres &lt;- results(dds, alpha = 0.05)\n\nresults &lt;- res %&gt;%\n  as.data.frame() %&gt;% \n  rownames_to_column(\"genes\") %&gt;%\n  arrange(padj)\n\n# Define significantly upregulated and downregulated genes with LFC and padj cutoffs\nlfc_cutoff &lt;- 1\npadj_cutoff &lt;- 0.05\n\n# Make new categorical variable containing significance information\nresults &lt;- results %&gt;% \n        mutate(significance = case_when(\n          padj &lt; padj_cutoff & log2FoldChange &gt; lfc_cutoff ~ 'Significantly upregulated',\n          padj &lt; padj_cutoff & log2FoldChange &lt; -lfc_cutoff ~ 'Significantly downregulated',\n          padj &lt; padj_cutoff ~ 'Significant but small effect size',\n          TRUE ~ 'Not significant'\n        ))\n\nDEGs_list &lt;- results %&gt;% filter(significance == \"Significantly upregulated\" | significance == \"Significantly downregulated\") %&gt;% pull(genes)\n\n\n\nLet’s remind ourselves of what our list of genes of interest now looks like. This list is stored in the variable DEGs_list:\n\n\n\nR\n\nhead(DEGs_list)\n\n\n[1] \"AT5G04120\" \"AT2G28780\" \"AT1G62280\" \"AT1G32450\" \"AT1G30530\" \"AT1G15380\"\n\nlength(DEGs_list)\n\n[1] 1397\n\n\nOk, this list contains of 1397 entries of Arabidopsis TAIR gene IDs.",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html#go-enrichment",
    "href": "episodes/05-pathway-enrichment.html#go-enrichment",
    "title": "Enrichment analysis",
    "section": "GO enrichment",
    "text": "GO enrichment\nWe can perform the GO enrichment analysis with the enrichGO() function, and then plot the results using dotplot()\n\n\n\nR\n\ngo_results &lt;- enrichGO(\n  gene          = DEGs_list,         # Your gene list\n  OrgDb         = org.At.tair.db,    # Arabidopsis TAIR10 annotation\n  keyType       = \"TAIR\",            # TAIR10 gene IDs (AT1Gxxx)\n  ont           = \"BP\",              # \"BP\" (Biological Process), \"MF\", \"CC\"\n  pAdjustMethod = \"BH\",              # Benjamini-Hochberg correction\n  pvalueCutoff  = 0.05,              # Significance threshold\n  qvalueCutoff  = 0.05,\n  readable      = TRUE               # Convert gene IDs to common names\n)\n\ndotplot(go_results, showCategory = 12, x = \"FoldEnrichment\")\n\n\n\n\n\n\n\n\n\nFor example, this plot shows us that genes with the GO annotation flavonoid biosynthetic process occur about 4.8 times as often in our gene list, compared to random chance (e.g., picking 1397 random genes from our background gene universe). The color further indicates the adjusted p-value, while the size of the dot corresponds to the number of genes belonging to this GO term in our gene list.\n\n\n\n\n\n\nQuestion\n\n\n\nRepeat the GO enrichment analysis for the Cellular Component (CC) category. Which cellular localizations are enriched in our list of DEGs?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\nR\n\ngo_results &lt;- enrichGO(\n  gene          = DEGs_list,         \n  OrgDb         = org.At.tair.db,    \n  keyType       = \"TAIR\",            \n  ont           = \"CC\",              \n  pAdjustMethod = \"BH\",             \n  pvalueCutoff  = 0.05,              \n  qvalueCutoff  = 0.05,\n  readable      = TRUE               \n)\n\ndotplot(go_results, showCategory = 10, x = \"FoldEnrichment\")\n\n\n\n\n\n\n\n\n\nIt looks like the plastid or chloroplast – the photosynthetic organelles of plants – are enriched in our DEG list, as well as secretory vesicles.\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nCome up with a way to get a better list of the background ‘universe’. Store this list in a variable called universe_list\nRepeat the BP GO enrichment with this universe and see if it changes your results. Hint: you have to add an argument to the enrichGO() function: universe = universe_list.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n1.\n\n\n\nR\n\nuniverse_list &lt;- results %&gt;% filter(baseMean &gt; 1) %&gt;% pull(genes)\nhead(universe_list)\n\n\n[1] \"AT5G04120\" \"AT2G28780\" \"AT1G62280\" \"AT1G32450\" \"AT1G30530\" \"AT1G15380\"\n\nlength(universe_list)\n\n[1] 27323\n\n\n2.\n\n\n\nR\n\ngo_results &lt;- enrichGO(\n  gene          = DEGs_list,\n  universe      = universe_list,         \n  OrgDb         = org.At.tair.db,    \n  keyType       = \"TAIR\",            \n  ont           = \"BP\",              \n  pAdjustMethod = \"BH\",             \n  pvalueCutoff  = 0.05,              \n  qvalueCutoff  = 0.05,\n  readable      = TRUE               \n)\n\ndotplot(go_results, showCategory = 10, x = \"FoldEnrichment\")\n\n\n\n\n\n\n\n\n\nIn this case, not so much changed compared to our earlier BP enrichment analysis, although some categories changed a little bit. At least, we will sleep better tonight, knowing that we performed a statiscally sound ORA.",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html#kegg-enrichment",
    "href": "episodes/05-pathway-enrichment.html#kegg-enrichment",
    "title": "Enrichment analysis",
    "section": "KEGG enrichment",
    "text": "KEGG enrichment\nKEGG terms describe gene functions at the level of pathways. While there will be quite some overlap with GO terms, it can happen that KEGG terms happen to describe what’s happening in your data a bit more clearly. Running and visualizing KEGG enrichment works very similar as GO term enrichment, but first we will need to find the ‘KEGG code’ of the organism we are studying, by searching by the scientific name.\n\n\n\nR\n\nkegg_result &lt;- search_kegg_organism('Arabidopsis thaliana', by='scientific_name')\nhead(kegg_result)\n\n\n    kegg_code      scientific_name common_name\n565       ath Arabidopsis thaliana thale cress\n\n\nAha, the KEGG code of Arabidopsis thaliana is ath.\n\n\n\nR\n\nKEGG_result &lt;- enrichKEGG(gene = DEGs_list,\n                                universe = universe_list,\n                                organism = \"ath\",\n                                minGSSize = 10,\n                                maxGSSize = 500,\n                                pAdjustMethod = \"BH\",\n                                qvalueCutoff = 0.05,\n                                use_internal_data = FALSE)\n\n\nReading KEGG annotation online: \"https://rest.kegg.jp/link/ath/pathway\"...\n\n\nReading KEGG annotation online: \"https://rest.kegg.jp/list/pathway/ath\"...\n\ndotplot(KEGG_result, x = \"FoldEnrichment\")",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html#gsea-gene-set-enrichment-analysis",
    "href": "episodes/05-pathway-enrichment.html#gsea-gene-set-enrichment-analysis",
    "title": "Enrichment analysis",
    "section": "GSEA (Gene Set Enrichment Analysis)",
    "text": "GSEA (Gene Set Enrichment Analysis)\nIn the GO and KEGG ORA sections, we started with a binary gene list, that is, ‘significant’ vs ‘not significant’. GSEA is another enrichment test that employs a different strategy. Here, we start with a ranked list of all the genes in our experiment. They might be ranked by Log2FoldChange, or adjusted p-value. Then, GSEA answers the following conceptual question:\n\nAre genes from a pathway consistently found toward the top or bottom of the ranked list?\n\nIn other words, ORA requires us to make a choice about a threshold of significance and/or fold change, while GSEA is a ‘threshold free’ method.\nFirst, we will prepare the data structure to perform GSEA:\n\n\n\nR\n\n1gene_list &lt;- results$log2FoldChange\n2names(gene_list) &lt;- results$genes\n\n3gene_list &lt;- gene_list[!is.na(gene_list)]\n4gene_list &lt;- sort(gene_list, decreasing = TRUE)\n\n\n\n1\n\nFirst, we take all the fold change values and store it in a list\n\n2\n\nThen, we add the gene IDs as names of the list items\n\n3\n\nWe remove all entries where there was no valid fold change values (NA)\n\n4\n\nThen, we sort the list.\n\n\n\n\nLet’s now run the GSEA:\n\n\n\nR\n\ngsea_go &lt;- gseGO(\n  geneList     = gene_list,\n  OrgDb        = org.At.tair.db,\n  keyType      = \"TAIR\",\n  ont          = \"BP\",\n  minGSSize    = 10,\n  maxGSSize    = 500,\n  pvalueCutoff = 0.05,\n  verbose      = FALSE\n)\n\ngseaplot2(\n  gsea_go,\n1  geneSetID = 1,\n  title = gsea_go@result$Description[1]\n)\n\n\n\n1\n\nBy picking 1 here, we will plot the GO term with the lowest p-value. Make sure to explore a few more than just the first one, by changing the 1 to other numbers. You can inspect all significant GO terms in table format by using summary(gsea_go).\n\n\n\n\n\n\n\n\n\n\n\nThis graph is rather complex but very interesting! Let’s break the most important parts down:\n\nThe green line shows the Running Enrichment Score, and the highest point is enrichment score of this GO category. If the peak is at the left, this pathway is enriched among up-regulated genes.\nEach vertical tick represents one gene from this GO term. So, there is clustering of (in this case) photosynthesis annotated genes in the top end of the ranked list.",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html#performing-enrichment-analysis-on-webservers",
    "href": "episodes/05-pathway-enrichment.html#performing-enrichment-analysis-on-webservers",
    "title": "Enrichment analysis",
    "section": "Performing enrichment analysis on webservers",
    "text": "Performing enrichment analysis on webservers\nSome people find it easier to use webservers for GO term enrichment. Of course, that’s also possible. For example, g:Profiler is an excellent webserver where you can simply paste a list of geneIDs, select your organism of study, hit Run query, and visually inspect the results. One big advantage of this webserver is that it contains GO annotations of hundreds of organisms, including many that are not available on Bioconductor for R-based analysis.",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/05-pathway-enrichment.html#concluding-remarks",
    "href": "episodes/05-pathway-enrichment.html#concluding-remarks",
    "title": "Enrichment analysis",
    "section": "Concluding remarks",
    "text": "Concluding remarks\nThis concludes the bioDSC workshop on RNA-seq. We went all the way from experimental design to mapping reads to differential gene expression in R. If you want to practice more with existing datasets, continue to the next episode.",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "episodes/03-mapping-reads.html",
    "href": "episodes/03-mapping-reads.html",
    "title": "From reads to alignments",
    "section": "",
    "text": "The moment is there: you received the FASTQ files from your sequencing provider! …. now what?\nThe .fastq files contain your RNA sequencing reads. Our goal is to find out from which genes these reads originate, and whether there are differentially expressed genes between your experimental factors. Before doing that, we need to make sure that the sequencing reads are of good quality, a process called quality control (QC). Additionally, no matter how good the overall quality of the sequencing data is, we will also ‘trim’ our reads to remove bad quality reads and sequencing adapters that may still be present in the sample. So, to summarize, we will do the following steps in this episode:\nThe commands in this episode are to be executed in a Google Colab notebook. We will use some basic terminal commands. You don’t need to understand every command, rather, the goal is to become familiar with RNA-seq concepts and steps. There are two versions of the notebook:",
    "crumbs": [
      "From reads to alignments"
    ]
  },
  {
    "objectID": "episodes/03-mapping-reads.html#quality-control-fastqc",
    "href": "episodes/03-mapping-reads.html#quality-control-fastqc",
    "title": "From reads to alignments",
    "section": "Quality control: fastqc",
    "text": "Quality control: fastqc\nThe first step in the RNA-seq workflow is to assess the quality of the sequencing reads. Sequence reads generated from next-generation sequencing technologies come in the FASTQ file format. This file format evolved from FASTA: it contains sequence data, but also contains quality information. For a single record (sequence read) there are four lines, each of which are described below:\n\n\n\n\n\n\n\nLine\nDescription\n\n\n\n\n1\nAlways begins with ‘@’ and then information about the read\n\n\n2\nThe actual DNA sequence\n\n\n3\nAlways begins with a ‘+’ and sometimes the same info in line 1\n\n\n4\nHas a string of characters which represent the quality scores; must have same number of characters as line 2\n\n\n\nLet’s look at one read. Note that our .fastq files are compressed: they have extension .fastq.gz. Most bioinformatics programs can deal with compressed file, so we don’t need to uncompress them. To have a look at a compressed file on the command line, we can use zcat and then pipe (|) the result into the head function to display the first 4 lines:\n\n\n\nbash\n\nzcat reads/sample1.fastq.gz | head -n 4\n\n@ERR1406259.2 HWI-ST1034:108:D1HW4ACXX:1:1101:1627:2208/1\nCCGAAACAATCTCTCTCTCGTCGCCGGAAGCAAAAGAAGAATTAAGATAAGCCTCATCCATCCAGTGATGCAAATCACCAACCCATATGGTTTTATTCTCA\n+\nCCCFFFFFHHHHHJJJIJJGIIIJJJFJJJJJJJIJIIGIIIJJJHIJJJHGHHHFFEFFFEDEEACDDDDDDDDDDDDDDDDDDDDDED4@BDDDDDEDC\n\n\nThe fourth line of each read represent the quality score of each basecall, see Wikipedia for more info. fastqc will use these characters to quantify the quality your read set.\nLet’s run fastqc on one sample:\n\n\n\nbash\n\n1mkdir fastqc_reports\n2fastqc -o fastqc_reports reads/sample1.fastq.gz\n\n\n\n1\n\nFirst we make a directory (mkdir) to store the fastqc reports.\n\n2\n\nWe call the fastqc program, tell it to store the output in the fastqc_reports directory, and tell it which sample to use.\n\n\n\n\nYou’ll see that fastqc created a .html page in the fastqc_reports directory. We’ll inspect it later.\n\n\n\n\n\n\nExercise\n\n\n\nRun fastqc on another sample.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTo do this, we need to replace the input filename.\n\n\n\nbash\n\nfastqc -o fastqc_reports reads/sample2.fastq.gz\n\n\n\n\n\nDoing this manually for every sample would be quite tiring, especially when we would have many samples. We will use a for loop, a fundamental programming concept, to automate this process for us:\n\n\n\nbash\n\n1for sample in reads/*.fastq.gz\n2do\n3  fastqc -o fastqc_reports ${sample}\ndone\n\n\n\n1\n\nHere we define a variable sample that will subsequently get the values of all datasets matching the reads/*.fastq.gz statement, where * acts as a wildcard.\n\n2\n\ndo (and later done) define the start and the end of the for loop, respectively.\n\n3\n\nHere we add the actual command that will be repeated for each sample, where $sample will subsequently be filled in with all of our four filenames.\n\n\n\n\nfastq generates reports of each sample in .html and .zip format:\n\n\n\nbash\n\n1ls fastqc_reports\n\nsample1_fastqc.html  sample2_fastqc.zip   sample4_fastqc.html\nsample1_fastqc.zip   sample3_fastqc.html  sample4_fastqc.zip\nsample2_fastqc.html  sample3_fastqc.zip\n\n\n\n1\n\nls is a command to ‘list’ all the files present in a directory.\n\n\n\n\nFinally, let’s inspect the QC results. If you are working in the Google Colab, you can browse the files in the workspace by clicking the directory symbol. Find fastqc_reports and download the .html files to your local computer. You can open these in any browser. fastqc gives each dataset a score (Pass, Warning, or Fail) on several different modules. All scores are reported in the Summary. The next section contains basic statistics like the number of reads, average sequence length, and the GC content. Generally it is a good idea to keep track of the total number of reads sequenced for each sample and to make sure the read length and GC content is as expected (based on what you know of your studied organism). One of the most important analysis modules is the “Per base sequence quality” plot. This plot provides the distribution of quality scores at each position in the read across all reads. This plot can alert us to whether there were any problems occuring during sequencing. For example, see a good and bad quality result below:\n\nOther modules are discussed in detail here. Note that nearly all sequencing datasets will show yellow warnings or red fails: fastqc is quite conservative. Additionally, the module “Per base sequence content” very often fails for RNA-seq data, as a result of RNA-seq library prep. Your experiment is not lost if you get warnings or fails, but it might warrant additional inspection of the reads. If you suspect something is wrong, don’t hesitate to contact the sequencing provider or your favorite bioinformatician.\n\n\n\n\n\n\nExercise\n\n\n\nInspect all four QC reports, and discuss with your neighbour what you think about them.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nSample 1, 2 and 3 are actually of good quality. Only the expected module (Per base sequence content) gives a FAIL, all other modules are green!\nFor sample 4 this is not the case. The quality score of the bases is low, especially towards the end of the reads. Also, fastqc detected a TruSeq sequencing adapter in a small portion of the reads.",
    "crumbs": [
      "From reads to alignments"
    ]
  },
  {
    "objectID": "episodes/03-mapping-reads.html#trimming-fastp",
    "href": "episodes/03-mapping-reads.html#trimming-fastp",
    "title": "From reads to alignments",
    "section": "Trimming: fastp",
    "text": "Trimming: fastp\nA common anomaly detected by fastqc is sequencing adapters still being present some of the the reads (shown in Overrepresented sequences table). This is known as ‘adapter contamination’, and the presence of these adapter sequences in the reads might affect how the reads map to the genome of interest. So, we need to get rid of them. We will use fastp to do this. In addition, fastp will trim low quality bases from the reads. Finally, it will remove reads that are overall of low quality, or are too short after the trimming steps.\n\n\n\nbash\n\nmkdir fastp_reports\nmkdir trimmed_reads\nfastp \\ \n  -i reads/sample1.fastq.gz \\\n  -o trimmed_reads/sample1.trimmed.fastq.gz \\\n  --thread 2 \\\n  --html fastp_reports/sample1_fastp_report.html\n\n\nfastp prints information about the trimming on the terminal, for example:\n\n\n\npartial output\n\nFiltering result:\nreads passed filter: 39343\nreads failed due to low quality: 10642\nreads failed due to too many N: 15\nreads failed due to too short: 0\nreads with adapter trimmed: 0\nbases trimmed due to adapters: 0\n\n\nThe same information is also saved as a nice .html page, you can download them and have a look.\n\n\n\n\n\n\nExercise\n\n\n\nAfter running fastp, the adapter contamination of sample 4 should be gone.\n\nHow could you check whether fastp indeed did it’s job?\nWrite a command to check this.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nWe can run fastqc again, this time on the trimmed reads.\n\n\n\n\n\nbash\n\nfastqc -o fastqc_reports_trimmed trimmed_reads/sample4.trimmed.fastq.gz\n\n\nBy inspecting the .html report of the trimmed reads, we should see that the quality of the read sets has now improved, and that it no longer detects the TruSeq adapters.",
    "crumbs": [
      "From reads to alignments"
    ]
  },
  {
    "objectID": "episodes/03-mapping-reads.html#mapping-star",
    "href": "episodes/03-mapping-reads.html#mapping-star",
    "title": "From reads to alignments",
    "section": "Mapping: STAR",
    "text": "Mapping: STAR\nOur reads are now ready for mapping. Mapping reads means figuring out where each read from the RNA-seq experiment originally came from within the genome. For RNA-seq experiments, it’s important to pick a splice-aware aligner, since a RNA-seq read can span an exon-intron-exon boundary. After all, the vast majority of RNA you sequenced is mature mRNA where introns have been spliced out.\n\n\n\nSplice-aware vs non-splice-aware alignment (image from Harvard Chan Bioinformatics Core)\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nSo, for RNA-seq we need splice-aware aligners. Can you come up with an experiment that would not require a splice-aware aligner program?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn experiments where we don’t need to think about exon-intron boundaries. This is the case when the reads originate from genomic DNA, for example for whole genome sequencing experiments, or enrichment sequencing experiments like Chip-Seq.\n\n\n\nTo use an aligner, we must first get the reference genome (e.g. via NCBI Genomes or organism specific databases), in .fa or .fasta format. You will also need an annotation file with all the predicted gene models (.gff or .gtfformat). For this workshop, the A. thaliana reference genome was included in the workshop materials.\nBefore we start mapping we need to index the reference genome. Indexing the genome prepares the genome in a way that allows a computer to search it efficiently. The genome, a multi-million basepair long string of text, is encoded into a different, computer-friendly datastructure such as a suffix tree. The details of this procedure are beyond the scope of this workshop, but it’s important to do it. The Arabidopsis thaliana genome is already present in the notebook. We make the index using STAR:\n\n\n\nbash\n\nSTAR --runMode genomeGenerate \\\n  --genomeSAindexNbases 12 \\\n  --genomeFastaFiles genome/TAIR10.fasta \\\n  --genomeDir TAIR10_STAR_index\n\n\nAllright, let’s finally run STAR. This tool requires quite some parameters to be set:\n\nHow many threads to use (--runThreadN)\nWhere to find the index (--genomeDir)\nEhere to find the reads (--readFilesIn)\nThat the reads are compressed (--readFilesCommand)\nWhere to store the results (--outFileNamePrefix)\nAnd which output file format we want (--outSAMtype)\n\n\n\n\nbash\n\nSTAR \\   \n  --runThreadN 2 \\ \n  --genomeDir TAIR10_STAR_index \\\n  --readFilesIn trimmed_reads/sample1.trimmed.fastq.gz \\\n  --readFilesCommand zcat \\\n  --outFileNamePrefix mapped_reads/sample1_ \\\n  --outSAMtype BAM SortedByCoordinate\n\n\nLet’s look at a mapping summary in a file generated by STAR that ends with .final.out. We can do that on the command line (using cat), or you can download the file and open it in a text editor.\n\n\n\nbash\n\ncat mapped_reads/sample1_Log.final.out\n\n\nIt’s important to check how many reads did not map to the reference genome. In our case, it looks like more than 95% of the reads mapped to the reference genome. That’s good! A high proportion of unmapped reads can be a warning sign that something went wrong in your experiment or analysis. The explanations may be technical (bad read quality), bioinformatical (perhaps you used the wrong reference genome!), or biological — it has been well documented that around 11% of primate and rodent cell-line RNA-seq datasets available on NCBI in 2015 were contaminated with mycoplasma RNA (Olarerin-George & Hogenesch, 2015). Likewise, 8,5% of all Arabidopsis thaliana NCBI RNA-seq datasets are contaminated with a virus that does not cause any disease symptoms, but can cover up to 80% of all reads generated in an RNA-seq experiment (Verhoeven et al., 2022). That said, we don’t need to aim for 100% reads mapped to the reference genome. There will always be some contamination, or your studied individual possesses genetic information not present in the reference genome.\n\nBAM and SAM files\nThe mapped reads are stored in a sorted .bam file by STAR. .sam (and .bam) files keep information for each individual read and its alignment to the genome. .sam files do this in a tab-seperated, human readable format, while .bam files store the same information in a binary file format that’s not readable for humans, but is much more efficient to process and store by computers. samtools is a widely used program to inspect and manipulate .sam and .bam files. Like many command line programs, samtools commands can be connected to each other via the pipe symbol |, and the results can be stored in a new file using the &gt; symbol.\n\n\n\n\n\n\nExercise\n\n\n\nUse the head command to inspect a .bam file.\n\nWhat do you see?\nUse samtools view command, piped (using |) into a common Unix program, to inspect the first 10 lines of the file.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\nbash\n\nhead mapped_reads/sample1_Aligned.sortedByCoord.out.bam\n\n\nThe output looks like gibberish, because .bam files are a binary file format.\n\nYou can use samtools view to make samtools read the binary file, and then pipe that result into the head function to show the first 10 lines:\n\n\n\n\nbash\n\nsamtools view mapped_reads/sample1_Aligned.sortedByCoord.out.bam | head\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUse the two following commands on a .bam file, and interpret the output.\n\nsamtools flagstat\nsamtools idxstats (Note: before running this command, you need to index the .bam file using samtools index mapped_reads/sample1_Aligned.sortedByCoord.out.bam)\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nsamtools flagstat shows us (just like the STAR log file) how many reads were mapped correctly. In addition, it tells us whether read pairs (if mapping paired-end data) mapped together as expected (are ‘properly paired’). Today, we used single-end reads so this is not relavant.\nsamtools idxstats shows us how many reads were mapped to each chromosome of the reference genome. This is useful to confirm whether the entire genome is evenly covered, or that there may be overrepresentation on e.g. the mitochondrial DNA.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nSo far, we only trimmed and mapped one sample. Trim and map the other three samples. Easy mode: repeat the commands performed earlier, update the sample numbers. For a challenge: write two bash for loops to process all four samples.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nFor loop to trim:\n\n\n\n\nbash\n\nfor sample in reads/*.fastq.gz\ndo\n  name=$(basename \"$sample\" .fastq.gz)\n  echo \"processing ${name}\"\n\n  fastp \\\n  -i reads/${name}.fastq.gz \\\n  -o trimmed_reads/${name}.trimmed.fastq.gz \\\n  --thread 2 \\\n  --html fastp_reports/${name}_fastp_report.html\ndone\n\n\n\nFor loop to map:\n\n\n\n\nbash\n\nfor sample in trimmed_reads/*.trimmed.fastq.gz\ndo\n  name=$(basename \"$sample\" .trimmed.fastq.gz)\n\n  software/STAR \\\n    --runThreadN 2 \\\n    --genomeDir TAIR10_STAR_index \\\n    --readFilesIn reads/${name}.trimmed.fastq.gz \\\n    --readFilesCommand zcat \\\n    --outFileNamePrefix mapped_reads/${name}_ \\\n    --outSAMtype BAM SortedByCoordinate\ndone\n\n\n\n\n\n\n\nInspecting the mapping on a genome browser\nSo far, these steps may have been quite abstract. Let’s make it more visual. We will look at our mapped reads in a genome browser.\n\nDownload a .bam file with accompanying .bam.bai index file.\nGo to the Arabidopsis page on Phytozome (or another website for your favorite organism).\nClick JBrowse.\nGo to File &gt; Open track file or URL &gt; Select Files... to find your files.\nClick Open!\n\n\nThat’s wonderful! You should see red and blue (forward and reverse) blocks aligning with the exons of the annotated gene models of A. thaliana. Also notice that some reads will be beautifully split over two or more introns. Good RNA-seq mapping should align predominantly to exons. If this is not the case, something might be wrong. For example, your RNA sample could have been contaminated with genomic DNA. Another option that could explain mappings to non-annotated regions of the genome, is that the annotation may not be complete.\nObviously, we can’t manually inspect all samples and all genes like this, so we will need to count the number of reads in each in gene in each sample. We will do that in the next and final step of today.",
    "crumbs": [
      "From reads to alignments"
    ]
  },
  {
    "objectID": "episodes/03-mapping-reads.html#counting-featurecounts",
    "href": "episodes/03-mapping-reads.html#counting-featurecounts",
    "title": "From reads to alignments",
    "section": "Counting: featureCounts",
    "text": "Counting: featureCounts\nThe featureCounts program will …. count (!) the number of reads that map within an annotated feature. Here, we chose to aggregate read count by gene (-t gene). Alternative options are transcript and exon (but they may require a different formatting of the annotation file).\n\n\n\nbash\n\nfeatureCounts \\\n  -T 2 \\\n  -O \\\n  -a genome/TAIR10_GFF3_genes.gff \\\n  -o counts.tsv \\\n  -t gene \\\n  mapped_reads/*.bam\n\n\nWhile running, featureCounts shows how many mapped reads were assigned to features. Finally, let’s look at the counts table that was generated:\n\n\n\nbash\n\nhead counts.tsv\n\n# Program:featureCounts v2.0.3; Command:\"featureCounts\" \"-T\" \"2\" \"-O\" \"-a\" \"genome/TAIR10_GFF3_genes.gff\" \"-o\" \"raw_counts.tsv\" \"-t\" \"gene\" \"mapped_reads/sample1_Aligned.sortedByCoord.out.bam\" \"mapped_reads/sample2_Aligned.sortedByCoord.out.bam\" \"mapped_reads/sample3_Aligned.sortedByCoord.out.bam\" \"mapped_reads/sample4_Aligned.sortedByCoord.out.bam\" \nGeneid  Chr Start   End Strand  Length  mapped_reads/sample1_Aligned.sortedByCoord.out.bam  mapped_reads/sample2_Aligned.sortedByCoord.out.bam  mapped_reads/sample3_Aligned.sortedByCoord.out.bam  mapped_reads/sample4_Aligned.sortedByCoord.out.bam\nAT1G01010   1   3631    5899    +   2269    0   0   0   0\nAT1G01020   1   5928    8737    -   2810    0   0   2   0\nAT1G01030   1   11649   13714   -   2066    0   0   0   0\nAT1G01040   1   23146   31227   +   8082    5   5   3   1\nAT1G01046   1   28500   28706   +   207 0   0   0   0\nAT1G01050   1   31170   33153   -   1984    3   6   4   0\nAT1G01060   1   33379   37871   -   4493    1   2   2   0\nAT1G01070   1   38752   40944   -   2193    1   0   0   0\n\n\nThe first row records the specific featureCounts command that we used to make this table. Ech subsequent row corresponds to a Geneid. The first six columns provide gene metadata: geneid, chromosome, start and end coordinates, strand, and gene length. All remaining columns contain the read counts of each sample.",
    "crumbs": [
      "From reads to alignments"
    ]
  },
  {
    "objectID": "episodes/03-mapping-reads.html#a-note-on-the-specific-tools-used-here",
    "href": "episodes/03-mapping-reads.html#a-note-on-the-specific-tools-used-here",
    "title": "From reads to alignments",
    "section": "A note on the specific tools used here",
    "text": "A note on the specific tools used here\nIn bioinformatics, there are often many ways to reach the same goal. Here we have selected mapping, trimming and counting tools that we have available and have experience with, but there are many others that perform just as well. The following table highlights a few popular alternative options:\n\n\n\nTask\nTool used here\nAlternative tools\n\n\n\n\nTrimming\nfastp\ncutadapt, trimmomatic\n\n\nMapping\nSTAR\nHISAT2\n\n\nCounting\nfeatureCounts\nStringTie\n\n\n\nInstead of real base-to-base read mapping using STAR or HISAT2, you can also consider quasi-mapping your reads to just the annotated transcript models using salmon. This is much faster and requires less storage space than real mapping, but for educational purposes and smaller scale experiments, true mapping is still more insightful.",
    "crumbs": [
      "From reads to alignments"
    ]
  },
  {
    "objectID": "episodes/03-mapping-reads.html#streamlining-read-mapping-procedure",
    "href": "episodes/03-mapping-reads.html#streamlining-read-mapping-procedure",
    "title": "From reads to alignments",
    "section": "Streamlining read mapping procedure",
    "text": "Streamlining read mapping procedure\nIf you find this process quite cumbersome, then I have good news for you! There are pipelines available that streamline the chain of commands required for mapping:\n\nsnakemake_rnaseq: developed at the Bleeker Lab (UvA).\nnf-core/rnaseq: developed and maintained by the Nextflow community.\nGalaxy server: if you prefer graphical interfaces over command lines, you can contact Frans van der Kloet for access to a Galaxy Server (for UvA/SILS researchers).\n\nA full instruction of these pipelines is beyond the scope of this workshop. Also, we wish to highlight that it is very insightful to have run all the steps by yourself rather than in a pipeline.",
    "crumbs": [
      "From reads to alignments"
    ]
  },
  {
    "objectID": "episodes/04-differential-gene-expression.html",
    "href": "episodes/04-differential-gene-expression.html",
    "title": "Differential gene expression analysis",
    "section": "",
    "text": "The main goal of most RNA-seq experiments is to discover which genes are differentially expressed between different groups (treatments, tissues, genotypes): the list of differentially expressed genes (DEGs). After the previous section, we now have a count table with the number of reads that map to each gene in each sample. How do we get to our goal from this table? We will need to use statistical models! In this section, we will use the DESeq2 package in R for differential gene expression analysis. Several other packages with different statistical models and assumptions exist (e.g. EdgeR and Limma): we pick DESeq2 because it is robust, widely-used, and user friendly.",
    "crumbs": [
      "Differential gene expression analysis"
    ]
  },
  {
    "objectID": "episodes/04-differential-gene-expression.html#reading-the-count-table-into-deseq2",
    "href": "episodes/04-differential-gene-expression.html#reading-the-count-table-into-deseq2",
    "title": "Differential gene expression analysis",
    "section": "Reading the count table into DESeq2",
    "text": "Reading the count table into DESeq2\nIn this tutorial, we will explore the transcriptomes of A. thaliana plants that experienced microgravity by growing on the International Space Station, while control plants were grown on earth. The experimental design is simple: there are three replicates in both conditions space_flight and ground_control.\n\n\n\n\n\n\nNote\n\n\n\nDownload the data from the repository of this workshop. Store the files in a folder on your computer. See below for a good workshop folder setup:\n\nRNA-seq-workshop\n├── data/\n│   ├── GLDS38_raw_counts.csv.csv\n│   └── samples_to_condition.csv\n├── data_processed/\n│   └── Normalized counts will go here\n├── results/\n│   └── Graphs will go here\n└── RNA-seq.R\n\n\n\nFirst we will load the packages that we need:\n\n\n\nR\n\nset.seed(1992)\n\nlibrary(DESeq2)\nlibrary(tidyverse)\nlibrary(ggrepel)\n\n\nThen, load the count table and metadata file:\n\n\n\nR\n\n1raw_counts &lt;- read.csv(\"data/GLDS38_raw_counts.csv\", header = T, stringsAsFactors = F)\n\n2raw_counts &lt;- raw_counts %&gt;% column_to_rownames(\"gene\")\n\nmetadata &lt;- read.csv(\"data/samples_to_condition.csv\", header = T)\n\nraw_counts[1:4,1:4]\n\n\n\n1\n\nMake sure you use the correct path to where your data is stored. Depending on your folder structure, you may not need the ../ and you could use data/GLDS38_raw_counts.csv instead.\n\n2\n\nHere, we store the column gene as row names instead of a dedicated column.\n\n\n\n\n          Atha_WT_Col_0_sl_FLT_Rep1_G1S1 Atha_WT_Col_0_sl_FLT_Rep2_G1S2\nAT1G01010                            339                            383\nAT1G01020                            126                            117\nAT1G01030                            153                            158\nAT1G01040                           1238                            442\n          Atha_WT_Col_0_sl_FLT_Rep3_G1S3 Atha_WT_Col_0_sl_GC_Rep1_G2S1\nAT1G01010                            363                           650\nAT1G01020                             89                            60\nAT1G01030                            143                            97\nAT1G01040                            543                           783\n\n\nThat looks good! Now, it’s important to note that DESeq2 expects the sample names (columns in count table) to exactly match the sample names in the metadata file, and be in the same order! For this small dataset, we can inspect that by eye. In addition, and probably useful for larger datasets, we can use the all() function to check this.\n\n\n\nR\n\nhead(metadata)\n\n\n                     sample_name      condition\n1 Atha_WT_Col_0_sl_FLT_Rep1_G1S1   space_flight\n2 Atha_WT_Col_0_sl_FLT_Rep2_G1S2   space_flight\n3 Atha_WT_Col_0_sl_FLT_Rep3_G1S3   space_flight\n4  Atha_WT_Col_0_sl_GC_Rep1_G2S1 ground_control\n5  Atha_WT_Col_0_sl_GC_Rep2_G2S2 ground_control\n6  Atha_WT_Col_0_sl_GC_Rep3_G2S3 ground_control\n\n\n\n\n\nR\n\n1all(colnames(raw_counts) == metadata$sample)\n\n\n\n1\n\nIf this does not return TRUE, you need to reorder or rename sample names in one of your files.\n\n\n\n\n[1] TRUE\n\n\n\nCreating the dds object\nWe are now ready to create a DESeqDataSet object, commonly abbreviated as dds. The dds object will contain our count tables and metadata, but later, also the normalized counts and differentially expressed gene lists. As such, the dds objects help us keep things neat in our RStudio session. To make one, we need to specify our experimental design ‘formula’. In this tutorial, there’s only one variable: the design formula will be as simple as ~ condition. However, in multi-factor experiments it can include additional variables, can also include unwanted sources of variation such as RNA isolation batch, the researcher who extracted RNA, or on which table the plants were grown. Including these factors in the design formula will help DESeq2 to account for these soures of variation, allowing more accurate estimation of the primary condition’s effect. For example, in an experiment with a potential batch effect, treatments, and different genotypes: ~ batch + treatment + genotype. If you also want to model the interaction, that is whether the treatment effect varies by genotype, change the + to a *: ~ batch + treatment * genotype.\n\n\n\nR\n\ndds &lt;- DESeqDataSetFromMatrix(countData = raw_counts, \n                              colData = metadata, \n                              design = ~ condition)\n\n\nWarning in DESeqDataSet(se, design = design, ignoreRank): some variables in\ndesign formula are characters, converting to factors",
    "crumbs": [
      "Differential gene expression analysis"
    ]
  },
  {
    "objectID": "episodes/04-differential-gene-expression.html#assesing-the-quality-of-an-rna-seq-experiment-via-pca",
    "href": "episodes/04-differential-gene-expression.html#assesing-the-quality-of-an-rna-seq-experiment-via-pca",
    "title": "Differential gene expression analysis",
    "section": "Assesing the quality of an RNA-seq experiment via PCA",
    "text": "Assesing the quality of an RNA-seq experiment via PCA\nAs essential step in RNA-seq analysis is to inspect similarity between samples. In particular, we should confirm that replicates with the same treatment are similar to each other, and make sure that the experimental condition is the major source of variation in the data. In addition, these quality-control explorations will also help identify if any samples behalve as outliers, or whether there may have been a sample swap. We will use Principal Component Analysis (PCA) to do this. PCA is a dimensionality reduction technique that transforms complex high-dimensional data (like expression of thousands of genes) into a limited number of new variables (‘principal components’) that capture the most variation in the dataset.\n\nPerforming variance stabilization\nBefore performing the PCA itself, we need to take an import feature of RNA-seq data into account: the variance of a gene is strongly correlated to the expression level of the gene. In statistics language, our data is not homoscedastic, while PCA assumes homoscedastic data. We can solve this by performing a variance stabilizing transformation vst():\n\n\n\nR\n\nvariance_stabilized_dataset &lt;- vst(dds, blind = TRUE)\n\n\nLet’s inspect the average expression and standard deviation of each gene to show that this transformation worked. In the following plots, each dot represents one A. thaliana gene:\n\n\n\nShow the code to make the plots\n\nR\n\nlibrary(patchwork)\n\nwithout_vst &lt;- raw_counts %&gt;% \n    as.data.frame() %&gt;% \n    rownames_to_column(\"gene\") %&gt;% \n    pivot_longer(cols = - gene, names_to = \"sample\", values_to = \"count\") %&gt;% \n    group_by(gene) %&gt;% \n    summarise(gene_mean = mean(count), gene_sd = sd(count)) %&gt;% \n    ungroup() %&gt;% \n    ggplot(aes(x = log10(gene_mean), y = log10(gene_sd))) +\n    geom_point(alpha = 0.2) +\n    labs(x = \"Gene count average\\n(log10 scale)\",\n        y = \"Gene count standard deviation\\n(log10 scale)\") +\n    ggtitle(\"No variance stabilization\")\n    \nvariance_stabilised_counts &lt;- assay(variance_stabilized_dataset)\n\nwith_vst &lt;- variance_stabilised_counts %&gt;% \n  as.data.frame() %&gt;% \n  rownames_to_column(\"gene\") %&gt;% \n  pivot_longer(cols = - gene, names_to = \"sample\", values_to = \"count\") %&gt;% \n  group_by(gene) %&gt;% \n  summarise(gene_mean = mean(count), gene_sd = sd(count)) %&gt;% \n  ungroup() %&gt;% \n  ggplot(aes(x = log10(gene_mean), y = log10(gene_sd))) +\n  geom_point(alpha = 0.2) +\n  labs(x = \"Gene count average\\n(log10 scale)\",\n       y = \"Gene count standard deviation\\n(log10 scale)\") +\n  ggtitle(\"Variance stabilized\")\n\nwithout_vst | with_vst\n\n\n\n\n\n\n\n\n\n\nShow the code to make the plots\nvariance_stabilised_counts_df &lt;- variance_stabilised_counts %&gt;%\n  as.data.frame() %&gt;% \n  rownames_to_column(\"gene\")  \n\nwrite.csv(variance_stabilised_counts_df, \"data_processed/variance_stabilized_dataset.csv\", row.names=FALSE)\n\n\nIndeed, we can observe that genes that are highly expressed (have high mean count) also have a high standard deviation. This correlation is no longer there after stabilizing the variance.\n\n\nPerforming the PCA\nOkay, finally we are ready to perform the PCA. DESeq2 makes this very easy for us with a simple function, plotPCA(), which directly gives us a PCA plot.\n\n\n\nR\n\nplotPCA(variance_stabilized_dataset)\n\n\nusing ntop=500 top features by variance\n\n\nWarning: `aes_string()` was deprecated in ggplot2 3.0.0.\nℹ Please use tidy evaluation idioms with `aes()`.\nℹ See also `vignette(\"ggplot2-in-packages\")` for more information.\nℹ The deprecated feature was likely used in the DESeq2 package.\n  Please report the issue to the authors.\n\n\n\n\n\n\n\n\n\nLet’s break this plot down:\n\nWe see that principal component 1 (PC1) explains 60% of the variance, while PC2 explains 29%. Those are nice scores. However, PC1 does not seem to separate our two conditions. This means that there’s another source of variation in this dataset that we are seemingly unaware of.\nWe see that PC2 nicely separates our two conditions. This is good!\n\nWe see that two samples from space_flight cluster very closely together, while one sample is quite a distant from those two. This means that this one replicate behaves a bit differently than the rest. However, since it’s still similar to the other two samples on the PC2 axis, this does not worry me.\n\nIf you want to have full control and make the PCA plot yourself in ggplot, you can add returnData=TRUE)\n\n\n\nR\n\npca_data &lt;- plotPCA(variance_stabilized_dataset, returnData=TRUE) \n\n\nWhile it is impossible to give examples of all situations that can occur in PCAs, we highlight a few below in fake PCA plots:\n\n\n\nShow the code to make the plots\n\nR\n\ndf_swap &lt;- data.frame(\n  PC1 = c(rnorm(5, mean = 1, sd = 0.2),   \n          rnorm(5, mean = -2, sd = 0.2)), \n  PC2 = c(rnorm(5, mean = 0.4, sd = 0.2),\n          rnorm(5, mean = 0.3, sd = 0.2)),\n  genotype = c(rep(\"WT\", 4), \"mutant\", rep(\"mutant\", 4), \"WT\"))\n\ndf_weak_sep &lt;- data.frame(\n  PC1 = c(rnorm(5, mean = 0.2, sd = 0.45),   \n          rnorm(5, mean = 0, sd = 0.6)), \n  PC2 = c(rnorm(5, mean = 0, sd = 0.25),\n          rnorm(5, mean = 0, sd = 0.25)),\n  genotype = rep(c(\"WT\", \"mutant\"), each = 5)\n)\n\np1 &lt;- df_swap %&gt;% ggplot(aes(x = PC1, y = PC2, colour = genotype)) + geom_point() +\n  xlab(\"PC1 (48%)\") +\n  ylab(\"PC2 (13%)\") +\n  ggtitle(\"Sample swap\")\n\np2 &lt;- df_weak_sep %&gt;% ggplot(aes(x = PC1, y = PC2, colour = genotype)) + geom_point() +\n    xlab(\"PC1 (12%)\") +\n    ylab(\"PC2 (4%)\") +\n    ggtitle(\"Weak separation\")\n\np1 | p2\n\n\n\n\n\n\n\n\n\n\nIn the first plot, we see one WT sample clustering with mutant samples, and vice versa. This is a clear indication that two samples were swapped somewhere in the process: during sampling, RNA extraction, cDNA synthesis, library prep, or in the metadata file. If you can trace this back in your labjournal, you could swap the sample label back. If not… it’s probably better to discard these two samples completely. In the second plot, we can see that there’s no clear separation between WT and mutant samples. In addition, the two PCs explain little of the variance present in the dataset. This is an indication that the genotype actually has little impact on the transcriptome. While worrying, this does not mean that all is lost! You can still proceed to differential expression analysis, maybe the difference between the two genotypes is quite subtle.\n\n\n\nShow the code to make the plots\n\nR\n\ndf_confounding_1 &lt;- data.frame(\n  PC1 = c(rnorm(5, mean = 1, sd = 0.45),   \n          rnorm(5, mean = -1, sd = 0.6)), \n  PC2 = c(rnorm(5, mean = 0, sd = 0.25),\n          rnorm(5, mean = 0, sd = 0.25)),\n  genotype = rep(c(\"WT\", \"mutant\"), each = 5),\n  gender = rep(c(\"male\", \"female\"), each = 5)\n)\n\np1 &lt;- df_confounding_1 %&gt;% ggplot(aes(x = PC1, y = PC2, colour = genotype)) + geom_point() +\n  xlab(\"PC1 (48%)\") +\n  ylab(\"PC2 (13%)\") +\n  ggtitle(\"Genotype effect ...\")\n\np2 &lt;- df_confounding_1 %&gt;% ggplot(aes(x = PC1, y = PC2, colour = gender)) + geom_point() +\n  xlab(\"PC1 (48%)\") +\n  ylab(\"PC2 (13%)\") +\n  ggtitle(\"... or gender effect?\")\n\np1 | p2\n\n\n\n\n\n\n\n\n\n\nIn this example, we see separation of our wildtype and mutant samples. Experiment succesful! … or is it? Upon closer inpection, we can see that gender of our samples also separates our samples in the same way. It turns out that all wildtypes were male mice, and all mutants were female. We will therefore never know if differentially expressed genes are caused by the genotype, or simply by the gender of the mice: a clear case of confounding variable. This is an experimental design flaw, and should have been caught before sampling. Yet, it happens!\n\n\n\n\n\n\nQuestion\n\n\n\nBesides PCA, how else could you assess whether replicate samples from the same treatment show similar results?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe can use a correlation analysis to do this. For this analysis, we will also need the variance stabilized counts.\n\n\n\nR\n\nlibrary(pheatmap)\n\ncorrelation_matrix &lt;- cor(variance_stabilised_counts)\n\nmetadata_2 &lt;- metadata %&gt;% column_to_rownames(\"sample_name\")\n\npheatmap(correlation_matrix, annotation_row = metadata_2, \n         clustering_distance_rows = \"correlation\", \n         clustering_distance_cols = \"correlation\", \n         display_numbers = TRUE, fontsize = 7)\n\n\n\n\n\n\n\n\n\nWe can see that all the ground_control and space_flight samples cluster together. For example, ground_control samples have a 0.98 or greater correlation with each other, while they have a slightly lower correlation with space_flight samples. However, the samples still have a high correlation also accross the different treatment. This shows that the transcriptomes are actually highly similar, regardless of treatment, probably because the majority of genes is not differentially expressed.",
    "crumbs": [
      "Differential gene expression analysis"
    ]
  },
  {
    "objectID": "episodes/04-differential-gene-expression.html#differential-gene-expression-analysis",
    "href": "episodes/04-differential-gene-expression.html#differential-gene-expression-analysis",
    "title": "Differential gene expression analysis",
    "section": "Differential gene expression analysis",
    "text": "Differential gene expression analysis\nDESeq2 handles all steps of DEG analysis, from sample normalization (e.g., to account for difference in sequencing depth per sample) to the statistical models and tests in one function. Easy! We run this function with the dds object as input, while storing the output in the dds object as well. In this way, we will ‘fill’ the dds object with the new analysis. R will now print all the individual steps that the DESeq() function performed for us.\n\n\n\nR\n\ndds &lt;- DESeq(dds)\n\n\nestimating size factors\n\n\nestimating dispersions\n\n\ngene-wise dispersion estimates\n\n\nmean-dispersion relationship\n\n\nfinal dispersion estimates\n\n\nfitting model and testing\n\n\nLet’s write the normalized counts to a file:\n\n\n\nR\n\nnorm_counts &lt;- counts(dds, normalized = TRUE)\n\nnorm_counts &lt;- norm_counts %&gt;% \n  as.data.frame() %&gt;%\n  rownames_to_column(\"gene_id\") \n\nwrite.csv(norm_counts, file = \"data_processed/normalized_counts.csv\", row.names = FALSE)\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nHow would you visualize the effect of the normalization on the distribution of read counts?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYou would make a boxplot of all the read counts per sample, for both raw counts and normalized counts.\n\n\n\nR\n\n# Get the raw counts and the normalized counts\nraw_counts &lt;- counts(dds, normalized=FALSE)\nnormalized_counts &lt;- counts(dds, normalized=TRUE) \n\n# Convert matrices to tidy format to visualize difference between raw and scaled counts\ntidy_raw &lt;-  raw_counts %&gt;% \n    as.data.frame() %&gt;% \n    rownames_to_column(\"Gene\") %&gt;% \n    pivot_longer(cols = -Gene, names_to = \"Sample\", values_to = \"counts\") %&gt;% \n    mutate(dataset = \"raw\")\n\ntidy_normalized &lt;- normalized_counts %&gt;% \n  as.data.frame() %&gt;% \n  rownames_to_column(\"Gene\") %&gt;% \n  pivot_longer(cols = -Gene, names_to = \"Sample\", values_to = \"counts\") %&gt;% \n  mutate(dataset = \"normalized\")\n\ntidy_total &lt;- rbind(tidy_raw, tidy_normalized)\n\n# boxplot shows that the medians of the samples moved closer to log10(2)\ntidy_total %&gt;% \n  ggplot(aes(x = Sample, y = log10(counts + 1))) +\n  geom_boxplot(aes(fill = dataset)) + facet_wrap(~ dataset)\n\n\n\n\n\n\n\n\n\nNotice how the median read counts of the normalized datasets are closer together than those of the raw read counts.\n\n\n\n\nLists of DEGs\nNow, to extract the list of DEGs from the dds we run another line of code. The argument alpha is used to specify the p-value cutoff for significance, the default value is alpha = 0.1. We will use 0.05 here. We will also sort the table on p-value:\n\n\n\nR\n\n1res &lt;- results(dds, alpha = 0.05)\n\n2summary(res)\n\n3results &lt;- res %&gt;%\n  as.data.frame() %&gt;% \n  rownames_to_column(\"genes\") %&gt;%\n  arrange(padj) \n\nhead(results) \n\n4write.csv(results, 'data_processed/all_genes_spaceflight_vs_ground.csv', quote = FALSE, row.names = FALSE)\n\n\n\n1\n\nGenerate results table\n\n2\n\nPrint a quick summary of the results: how many genes are significantly differentially expressed?\n\n3\n\nTurn results table into a data frame, generate a genes column from the rownames, make a new column with -log10 transformed p-values, then sort by adjusted p-value.\n\n4\n\nWrite to a file!\n\n\n\n\n\nout of 30151 with nonzero total read count\nadjusted p-value &lt; 0.05\nLFC &gt; 0 (up)       : 1792, 5.9%\nLFC &lt; 0 (down)     : 1557, 5.2%\noutliers [1]       : 16, 0.053%\nlow counts [2]     : 7564, 25%\n(mean count &lt; 8)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n\n      genes  baseMean log2FoldChange     lfcSE      stat       pvalue\n1 AT5G04120  456.5672       3.626601 0.2462679  14.72625 4.373346e-49\n2 AT2G28780 1964.3983      -3.630964 0.3295509 -11.01792 3.132194e-28\n3 AT1G62280  217.8345      -3.901515 0.3558769 -10.96310 5.749324e-28\n4 AT1G32450 5241.0272      -3.468312 0.3201042 -10.83495 2.350980e-27\n5 AT1G30530  708.2953       2.033682 0.1938999  10.48831 9.776462e-26\n6 AT1G15380  739.4577      -2.714855 0.2601611 -10.43529 1.710992e-25\n          padj\n1 9.871079e-45\n2 3.534838e-24\n3 4.325600e-24\n4 1.326599e-23\n5 4.413291e-22\n6 6.436465e-22\n\n\nThere is a row for each gene in this dataframe. We’ll discuss the most important columns below:\n\nbaseMean: is the mean of the normalized counts, across all samples.\nlog2FoldChange: is a way to describe how much the gene expression changes between the two conditions tested.\npvalue and padj: the result from the Wald test to test whether the expression is different between the two conditions tested. pvalue is the ‘raw’, uncorrected value, while padj is adjusted for multiple testing (of thousands of genes).\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nWhat is the biological meaning of a log2 fold change of 1?\nSimilarly, what is the biological meaning of a log2 fold change of -1?\nCompute the log2FoldChange (“treated vs untreated”) of a gene that has an average expression of 230 in treated condition, and 75 in untreated condition.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n1 and 2:\nA normal fold change would be calculated as such:\n\\[\n\\frac{\\text{mean expression B}}{\\text{mean expression A}}\n\\]\nIf a gene’s expression is not changed, the fold change would be 1, a fold change of 2 means double expression, while 0.5 means that the expression is halved. Taking the log2() of the fold change:\n\\[\n\\log_2\\left(\\frac{B}{A}\\right)\n\\]\nhelps to make the fold change symmetric and easier to interpret:\n\n\n\nlog2FC\nMeaning\nFold change\n\n\n\n\n+2\nLarge increase\n4×\n\n\n+1\nIncrease\n2×\n\n\n0\nNo change\n1×\n\n\n−1\nDecrease\n0.5× (half)\n\n\n−2\nLarge decrease\n0.25×\n\n\n\n3:\n\nlog2(230/75)\n\n[1] 1.616671\n\n\n\n\n\n\nShrinkage of fold changes\nDESeq2 allows for the shrinkage of log2FoldChanges values towards zero if the information for a gene is low (e.g. low amount of counts). See DESeq2 vignette for more information. In this workshop, we will skip this step.\n\n\nExtra contrasts\nIn our simple experimental setup, only one contrast is possible: space_flight vs ground_control. That’s why would could simply call res &lt;- results(dds, alpha = 0.05) to generate our results table. If we would have had another condition, for example, the plants were also grown with Martian gravity levels, we could have specified the contrast we wanted to test:\n\n\n\nR\n\ncontrast_to_test &lt;-  c(\"condition\", \"martian_gravity\", \"ground_control\")\nres_martian_vs_ground &lt;- results(dds, contrast=contrast_to_test, alpha = 0.05)\n\n\n\n\n\nVolcano plots\nOne way to visualize DEG results is to display them in a Volcano plot. Such a plot shows a measure of effect size (log2FoldChange) versus a measure of significance (padj). There are tools available (developed by Joachim Goedhart, assistant professor at SILS) to help you make such a plot using the DEG list we just saved as a .csv file. Alternatively, we can make one ourselves for full control of the plot:\n\n\n\nR\n\n# Define fold change and p-value cutoffs\nlfc_cutoff &lt;- 1\npadj_cutoff &lt;- 0.05\n\n# Make new categorical variable containing significance information\nresults &lt;- results %&gt;% \n        mutate(significance = case_when(\n          padj &lt; padj_cutoff & log2FoldChange &gt; lfc_cutoff ~ 'Significantly upregulated',\n          padj &lt; padj_cutoff & log2FoldChange &lt; -lfc_cutoff ~ 'Significantly downregulated',\n          padj &lt; padj_cutoff ~ 'Significant but small effect size',\n          TRUE ~ 'Not significant'\n        ))\n\nDEGs &lt;- results %&gt;% filter(significance == \"Significantly upregulated\" | significance == \"Significantly downregulated\")\nwrite.csv(DEGs, 'data_processed/DEGs_spaceflight_vs_ground.csv', quote = FALSE, row.names = FALSE)\n\ncolors &lt;- c(\"Significantly upregulated\" = \"#E69F00\", \n            \"Significantly downregulated\" = \"#56B4E9\", \n            \"Not significant\" = \"gray80\", \n            \"Significant but small effect size\" = 'grey50')\n\n# select top 10 genes to highlight\ntop_genes &lt;- results[1:10, ]\n\nvolcano &lt;- results %&gt;% \n  ggplot(aes(x = log2FoldChange, y = -log10(padj), colour = significance)) +\n  geom_point(alpha = 0.5, size = 0.8) + \n  geom_hline(aes(yintercept = -log10(padj_cutoff)), linetype = \"dashed\") +\n  geom_vline(aes(xintercept = lfc_cutoff), linetype = \"dashed\") +\n  geom_vline(aes(xintercept = -lfc_cutoff), linetype = \"dashed\") +\n  geom_point(data = top_genes, shape = 21,fill = NA, color = \"black\") +  # Highlight top10\n  geom_text_repel(data = top_genes, aes(label = genes), size = 2, min.segment.length = 0) +\n  scale_color_manual(values=colors) +\n  xlim(c(-10,10)) +\n  theme_bw() \n\nggsave(\"results/volcano_plot.png\", volcano, width = 14, height = 8, units = \"cm\")\n\n\nWarning: Removed 10262 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\nvolcano \n\nWarning: Removed 10262 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe can plot the DESeq2-normalized counts of two genes, just to confirm whether the volcano plot is correct. We pick one that is highly upregulated in space_flightconditions (AT5G04120), and one that is strongly downregulated (AT1G62280).\n\n\n\nR\n\ngene_1 &lt;- plotCounts(dds, gene=\"AT5G04120\", intgroup=\"condition\", \n                returnData=TRUE)\n\ngene_2 &lt;- plotCounts(dds, gene=\"AT1G62280\", intgroup=\"condition\", \n                        returnData=TRUE)\n\ngene_1 %&gt;% ggplot(aes(x = condition, y = count, colour = condition)) +\n  geom_jitter(width = 0.05) +\n  theme_bw()\n\n\n\n\n\n\n\n\ngene_2 %&gt;% ggplot(aes(x = condition, y = count, colour = condition)) +\n  geom_jitter(width = 0.05) +\n  theme_bw()\n\n\n\n\n\n\n\n\nYep, that seems about right.\n\n\nHeatmap\nAlternatively, we could also display the expression levels of the DEGs in a heatmap. With the following code, we make a ‘tidy’ dataframe from the variance stabilised counts, and select only the genes that we consider DEGs. Remember, these are the genes that passed both a padj threshold and log2FoldChange threshold above.\n\n\n\nR\n\nvariance_stabilised_df &lt;- variance_stabilised_counts %&gt;% \n  as.data.frame() %&gt;% \n  rownames_to_column(\"gene\") %&gt;% \n  pivot_longer(cols = - gene, names_to = \"sample\", values_to = \"count\")\n\nselection &lt;- DEGs$genes\n\nvsd_selection &lt;- variance_stabilised_df %&gt;% \n                    filter(gene %in% selection) %&gt;%\n                    merge(metadata, by.x = \"sample\", by.y = \"sample_name\")\n\n\nThen, we draw a heatmap using the tidyheatmaps package. Essentially, this is a tidyverse-style wrapper of the more famous heatmap package pheatmap.\n\n\n\nR\n\nlibrary(tidyheatmaps)\n\nheatmap &lt;- tidyheatmap(df = vsd_selection,\n            rows = gene,\n            columns = sample,\n            values = count,\n1            scale = \"row\",\n            annotation_col = c(condition),\n            gaps_col = condition,\n2            cluster_rows = TRUE,\n            # cluster_cols = TRUE,\n            color_legend_n = 7,\n            show_rownames = FALSE,\n            show_colnames = FALSE\n)\nheatmap\n\n\n\n1\n\nScaling is very important here! Try removing this line, and see what happens to the heatmap. It will be dominated by some genes that are very highly expressed.\n\n2\n\nThis argument makes sure that genes with a similar expression pattern are clustered together in the heatmap.\n\n\n\n\n\n\n\n\n\n\n\nThat looks pretty good. We can see that there are two clusters of genes: those expressed higher in the spaceflight condition, and those higher expressed in the ground_control condition. We can ask tidyheatmaps to gather genes into such clusters by adding the kmeans_k argument:\n\n\n\nR\n\nheatmap &lt;- tidyheatmap(df = vsd_selection,\n            rows = gene,\n            columns = sample,\n            values = count,\n            scale = \"row\", \n            annotation_col = c(condition),\n            gaps_col = condition,\n1            kmeans_k = 2,\n            cluster_rows = TRUE, \n            # cluster_cols = TRUE,\n            color_legend_n = 7,\n2            show_rownames = TRUE,\n            show_colnames = FALSE\n)\nheatmap\n\n\n\n1\n\nThis argument is added to perform k-means clustering and gather different genes into n clusters, in this case, 2 clusters.\n\n2\n\nSince we will be plotting just two clusters, we can set show_rownames to TRUE.\n\n\n\n\n\n\n\n\n\n\n\nThis simplifies our heatmap into two clusters, as expected. As you can imagine, more complex (and more interesting!) clustering patterns may emerge when the experimental design gets more complicated.",
    "crumbs": [
      "Differential gene expression analysis"
    ]
  },
  {
    "objectID": "episodes/04-differential-gene-expression.html#whats-next",
    "href": "episodes/04-differential-gene-expression.html#whats-next",
    "title": "Differential gene expression analysis",
    "section": "What’s next",
    "text": "What’s next\nSo far, we managed to find lists of genes that we find interesting. For example, we could be interested in all genes that are differentially expressed between two conditions, or choose to zoom in to only the upregulated or downregulated genes. In the next section, we will look into characterizing lists of genes using overrepresentation analysis. For example, we will look at GO-term enrichment.",
    "crumbs": [
      "Differential gene expression analysis"
    ]
  },
  {
    "objectID": "episodes/02-experimental-considerations.html",
    "href": "episodes/02-experimental-considerations.html",
    "title": "Before the experiment",
    "section": "",
    "text": "Before diving into the bioinformatics of RNA-seq experiments, it’s good to take a step back and think about experimental design and refresh your statistical knowledge. After all, an RNA-seq experiment is also an experiment like any other.",
    "crumbs": [
      "Before the experiment"
    ]
  },
  {
    "objectID": "episodes/02-experimental-considerations.html#hypothesis-testing",
    "href": "episodes/02-experimental-considerations.html#hypothesis-testing",
    "title": "Before the experiment",
    "section": "Hypothesis testing",
    "text": "Hypothesis testing\nIn an RNA-seq experiment, you will analyze the expression levels of thousands of genes. Before doing that, let us consider statistical tests and their associated p-values for a single gene. Let’s say you are studying a plant gene called “heat stress trancripion factor A-2 (HSFA2)”, whose expression might be induced by…. heat stress (you might have guessed that). You could phrase your null hypothesis:\n\n“The average HSFA2 gene expression is the same in normal conditions and under heat stress in my Arabidopsis seedlings”\n\nThe corresponding alternative hypothesis could then be:\n\n“The average HSFA2 gene expression is different under heat stress compared to normal conditions in my Arabidopsis seedlings”\n\nYou set up an experiment in the greenhouse. You grow Arabidopsis thaliana seedlings, and give half of them a heat stress treatment. Then, you take samples of 20 plants in both control and heat stressed conditions, and measure the expression levels of HSF2A. Let’s visualize this in a boxplot made in R, using the ggplot2 package.\n\n\n\nR\n\nlibrary(tidyverse)\nset.seed(1992)\n\ncontrol &lt;- tibble(expression = rnorm(n = 20, mean = 2, sd = 0.6), \n                    condition = \"control\")\nheat_stress &lt;- tibble(expression = rnorm(n = 20, mean = 3.4, sd = 0.3),\n                    condition = \"heat stress\") \n                         \nexperiment &lt;- bind_rows(control, heat_stress)\n\nggplot(experiment, aes(x = condition, y = expression)) + \n    geom_boxplot(aes(fill = condition), alpha = 0.5, outlier.shape = NA) +\n    geom_jitter(width = 0.2, alpha = 0.5) +\n    theme_classic()\n\n\n\n\n\n\n\n\n\nIndeed, HSF2A is highly expressed in heat stressed plants. The thick line of the boxplots show the median HSF2A expression in both groups. The median is a measure of central tendency. You will also see that the individual datapoints are dispersed around the boxplot: quantifying this gives us a measure of the spread of the data. An example of such a measure of spread is the standard deviation. It looks like our heat stressed plants display a more narrow spread of the data, compared to the plants grown in the control condition.\n\n\n\n\n\n\nQuestion\n\n\n\nCan you name another measure of central tendency? And another one for the measure of spread?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nAnother often used measure of central tendency would be the mean. As for the measure of spread, the variance (square of the standard deviation) or the standard error (standard deviation divided by the square root of the number of observations) are often used.\n\n\n\nLet’s test whether the means of the two groups are equal or not. We do this with a two-sample t-test.\n\n\n\nR\n\nt.test(x = control$expression,\n       y = heat_stress$expression,\n       alternative = \"two.sided\" ,      \n       var.equal = FALSE,             # important as the variance do not seem equal\n       conf.level = 0.95)             # this corresponds to alpha = 0.05 \n\n\n\n    Welch Two Sample t-test\n\ndata:  control$expression and heat_stress$expression\nt = -12.237, df = 25.636, p-value = 3.312e-12\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -1.600116 -1.139603\nsample estimates:\nmean of x mean of y \n 1.970023  3.339883 \n\n\nBecause the p-value &lt; 0.05, we can safely reject our null hypothesis, and claim that we have discovered that Arabidopsis significantly upregulates the expression of HSF2A under heat stress. Sounds like it’s time to write this down and submit a manuscript to Nature!",
    "crumbs": [
      "Before the experiment"
    ]
  },
  {
    "objectID": "episodes/02-experimental-considerations.html#statistical-power",
    "href": "episodes/02-experimental-considerations.html#statistical-power",
    "title": "Before the experiment",
    "section": "Statistical power",
    "text": "Statistical power\nStatistical power is the probability of your experimental sample population to detect a difference (in gene expression differences), given that an an effect actually exist in your experimental setup. There are two main error one could make when testing hypotheses. Type I errors occur when the null hypothesis is rejected wrongly — you detect a significant difference while in reality there is no difference in gene expression (“false positive”). Type II errors also are common in hypothesis testing — they arise if you accept the null hypothesis when in fact a treatment effect exists (“false negative”).\n\n\n\nType I and Type II error - schematic visualization\n\n\nThe power of an experiments is affected by several factors:\n\nThe number of replicates: more biological replicates results in a higher power\nSize of the effect: bigger differences between groups are easier to detect\nVariability of the data: less within-group variation makes it easier to detect differences\nConfidence level threshold: usually, this is 0.05, but we can make our analysis more or less stringent by changing this to 0.01 or 0.1",
    "crumbs": [
      "Before the experiment"
    ]
  },
  {
    "objectID": "episodes/02-experimental-considerations.html#what-determines-the-power-of-an-rna-seq-experiment",
    "href": "episodes/02-experimental-considerations.html#what-determines-the-power-of-an-rna-seq-experiment",
    "title": "Before the experiment",
    "section": "What determines the power of an RNA-seq experiment?",
    "text": "What determines the power of an RNA-seq experiment?\nRNA-seq experiments measure the expression levels of thousands of genes simultaneously, meaning we perform thousands of statistical tests at once. To avoid making too many false discoveries (type I errors), we have to correct for multiple testing. However, it also reduces statistical power — increasing the chance of missing real differences (type II errors). As a result, RNA-seq experiments can have lower power, especially for detecting small or subtle changes in gene expression. So, how do we deal with that? We have a few parameters to play with when designing an RNA-seq experiment, including deciding the number of reads per sample, and the number of samples per treatment.\nA fun tool to play with these parameters is the following RNASeq Power calculator. For example, with sequencing depth 50 and coefficient of variation 0.3, you would need about 5 biological replicates to detect genes with 100% increase in gene expression (effect size 2) with a power of 0.9:\n\n                 Power→\nEffect               0.8          0.9\nsize    1.25   34.678609    46.424819\n ↓      1.5    10.503242    14.060861\n        1.75    5.513793     7.381404\n        2       3.594011     4.811361\n\nIn addition, notice how hard it is to detect subtle differences in gene expression: for genes with a 50% difference in expression, you would already need 14 biological relicates.\n\n\n\n\n\n\nQuestion\n\n\n\nTry playing with the sequencing depth. Increase it 10-fold, another 10-fold, and even much higher. Does it reduce the amount of biological replicates needed to detect differences in gene expression with the same power?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nIt decreased the number of required replicates slightly, but the gain plateaus rather quickly. In other words, sequencing deeper does not increase the power of an RNA-seq experiment that much.\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nChange the calculator to the following settings:\n\nVariable to estimate: power\nSequencing depth: 20,50,100,400\nNumber of samples: 3,5,7,10\nCoefficient of variation: 0.4\nEffect: 1.25,1.5,1.75,2\nAlpha = 0.05\n\nYou now get 4 blocks of results, where the power is estimated depending on variable depth, number of samples, and effect size.\nWhat can you conclude from these estimations? Discuss with your neighbour if you are in a workshop with other participants.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n, , 1.25\n\n             3         5         7        10\n20  0.08634867 0.1170142 0.1470927 0.1918402\n50  0.09411991 0.1295846 0.1645339 0.2165511\n100 0.09729343 0.1347429 0.1717005 0.2266881\n400 0.09992041 0.1390222 0.1776482 0.2350900\n\n, , 1.5\n\n            3         5         7        10\n20  0.1904300 0.2874068 0.3803127 0.5073813\n50  0.2149137 0.3267574 0.4317066 0.5702555\n100 0.2249586 0.3427107 0.4521639 0.5944392\n400 0.2332846 0.3558407 0.4688270 0.6137674\n\n, , 1.75\n\n            3         5         7        10\n20  0.3212064 0.4883900 0.6272800 0.7795521\n50  0.3652380 0.5499761 0.6941715 0.8387834\n100 0.3829823 0.5738029 0.7187902 0.8588079\n400 0.3975363 0.5929072 0.7379987 0.8737350\n\n, , 2\n\n            3         5         7        10\n20  0.4572159 0.6669916 0.8077945 0.9225229\n50  0.5163439 0.7334376 0.8635761 0.9547953\n100 0.5394269 0.7574533 0.8820190 0.9640029\n400 0.5580268 0.7760088 0.8956052 0.9702800\n\n\nThe major conclusion is the same as before: increasing sample size is more important than sequencing depth to reach a higher detection power.\nSmall effect sizes are very hard to detect, even with rather large sample sizes, reaching a maximum power of about 0.25 with the current settings.\n\n\n\n\nTo connect these theoretical estimates to reality, let’s look at a study that examined RNA-seq power using real data. Liu et al., 2014 investigated this systematically in an RNA-seq experiment with a human cell line, by downsampling reads or samples. An exerpt from figure 1 is show below:\n\n\n\nImage adapted from Liu et al., 2014\n\n\nThe figure shows the relationship between sequencing depth and number of replicates on the number of differentially expressed genes (DEGs) identified. It illustrates that biological replicates are of greater importance than sequencing depth. Above 10M-15M reads per sample, the number of DEGs increases marginally, while adding more biological replicates tends to return more DEGs. A similar conclusion was also reached by Schurch et al., 2016. So, if your experiment is limited by a certain sequencing budget, it is almost always better to add more replicates than to sequence more reads of a limited number of samples. However, there are some caveats here. Say you are interested in the transcriptome of a fungal pathogen growing in plant roots. In such samples, most reads will probably come from the plant roots, so you will need to sequence deeply (that is, many reads from the same sample) to find DEGs from the fungal pathogen.",
    "crumbs": [
      "Before the experiment"
    ]
  },
  {
    "objectID": "episodes/02-experimental-considerations.html#experimental-design",
    "href": "episodes/02-experimental-considerations.html#experimental-design",
    "title": "Before the experiment",
    "section": "Experimental design",
    "text": "Experimental design\nIn a typical biological experiment, you will encounter various sources of variation that are either:\n\nDesirable because they are part of your experimental factors. For example, the genotype, treatment, or timepoint.\nUndesirable because you are not interested in them. This could be: batch of RNA isolation, location of plants in the greenhouse, …\n\nUndesirable variation is unavaidable, but there are some practices to limit their impact. First of all, make sure that you don’t confound your experimental factors with undesirable sources of variation by properly randomizing your treatments. For example, if you have too many samples to isolate RNA in one day of labwork, make sure you don’t isolate RNA from samples with genotype A on day 1, and genotype B on day 2. Instead, mix your samples of genotype A and B over your two RNA isolation days. Still, you should always record known sources of undesirable variation so you can correct for it later. There’s much more to be said about this, for more details see these materials from Harvard Chan Bioinformatics Core.",
    "crumbs": [
      "Before the experiment"
    ]
  },
  {
    "objectID": "episodes/02-experimental-considerations.html#concluding-remarks",
    "href": "episodes/02-experimental-considerations.html#concluding-remarks",
    "title": "Before the experiment",
    "section": "Concluding remarks",
    "text": "Concluding remarks\nIn this section, we refreshed our statistics knowledge, and discussed how this applies to RNA-seq experiments. Hopefully, this enables you to craft a well-designed and controlled RNA-seq experiment. Now, head to the lab or greenhouse, perform your experiment, and extract high-quality RNA. How to do this will depend on your study system, and is beyond the scope of this workshop. We will see you again when you get the sequencing reads from the sequencing provider. We will then jump into the bioinformatics pipeline required to check the quality of the reads, and map the reads to the genome of your organisms of interest.",
    "crumbs": [
      "Before the experiment"
    ]
  },
  {
    "objectID": "episodes/01-setup.html",
    "href": "episodes/01-setup.html",
    "title": "Setting up",
    "section": "",
    "text": "All bioinformatics projects requires setting up the required software. Let’s go through the setup for this RNA-seq workshop here.",
    "crumbs": [
      "Setting up"
    ]
  },
  {
    "objectID": "episodes/01-setup.html#from-reads-to-alignments",
    "href": "episodes/01-setup.html#from-reads-to-alignments",
    "title": "Setting up",
    "section": "From reads to alignments",
    "text": "From reads to alignments\n\nThe first part is the ‘hardcore’ bioinformatics part of this workshop. These steps are nearly always performed using command-line programs, which can be accessed via the Terminal (macOS, Linux) or WSL (Windows). For this workshop, we prepared a Google Colab environment where we will run the commands. Access to the Google Colab environment requires a Google account.\n\nEmpty Google Colab environment: to write the commands yourself\nPre-filled Google Colab environment: to execute prewritten commands\n\nIn a real experiment, you will often have so many samples and reads that you will need access to a compute cluster with more compute power (CPUs), working memory (RAM), and storage space. At the University of Amsterdam, we use Crunchomics. Crunchomics comes with many popular bioinformatics pre-installed, additional programs can be installed using conda.",
    "crumbs": [
      "Setting up"
    ]
  },
  {
    "objectID": "episodes/01-setup.html#differential-gene-expression-with-deseq2",
    "href": "episodes/01-setup.html#differential-gene-expression-with-deseq2",
    "title": "Setting up",
    "section": "Differential gene expression with DESeq2",
    "text": "Differential gene expression with DESeq2\n\nFor the second of the workshop, we will use R. Please make sure you have R and RStudio installed on your computer. In addition, you will need to install the following packages, via two different routes:\nInstall the following packages via install.packages()\n\n\n\nR\n\ninstall.packages('tidyverse')\ninstall.packages('patchwork')\ninstall.packages(\"pheatmap\")\ninstall.packages(\"BiocManager\")\n\n\nInstall the following packages via Bioconductor\n\n\n\nR\n\nBiocManager::install(\"apeglm\")\nBiocManager::install(\"clusterProfiler\")\nBiocManager::install(\"org.At.tair.db\")\nBiocManager::install(\"DESeq2\")\n\n\nTest whether DESeq2 was installed properly by loading it:\n\n\n\nR\n\nlibrary(DESeq2)\n\n\nDuring the workshop, we will not have time to install the packages, or to troubleshoot installation problems. Please try to install the packages before the workshop. You can always contact the workshop organizers if you run into problems.",
    "crumbs": [
      "Setting up"
    ]
  },
  {
    "objectID": "episodes/01-setup.html#getting-the-data",
    "href": "episodes/01-setup.html#getting-the-data",
    "title": "Setting up",
    "section": "Getting the data",
    "text": "Getting the data\nThe reads and reference that will be used in this workshop can be found in the following Github repository, and will be downloaded into the Google Colab automatically.\nThe count table and experimental design file used in the DESeq2 part of this workshop can be found here.",
    "crumbs": [
      "Setting up"
    ]
  },
  {
    "objectID": "episodes/06-practice-more.html",
    "href": "episodes/06-practice-more.html",
    "title": "Practice on your own",
    "section": "",
    "text": "In this workshop, we went all the way from experimental design, to bioinformatic processing of .fastq files, to differential gene expression analysis in DESeq2. We hope that you are now ready to design and analyze your own transcriptomics experiments. Remember that we only covered the very basics of transcriptome analysis, expect to learn a lot more when you start analyzing your own data.\nIf you first want to practice more, or don’t have your own data yet, you can analyze publicly available RNA-seq datasets. Papers often make their raw sequencing reads available on NCBI or ENA, which you can download to reanalyze. A repository where pre-processed count tables are available is EMBL-EBI. We collected four count tables to practice DESeq2 analysis, from three different domains of the life sciences. They are available in the practice/ folder of the GitHub repository of this workshop.\nPractice dataset #2 has one experimental factor, just like the dataset we worked with so far. However, it has five different levels, so it’s a bit more complex. All other practice datasets (#1, #3, and #4) include two or mroe experimental factors. This makes the analysis more complex but also more informative, especially since your own experiments will probably involve multiple factors as well.",
    "crumbs": [
      "Practice on your own"
    ]
  },
  {
    "objectID": "episodes/06-practice-more.html#the-datasets",
    "href": "episodes/06-practice-more.html#the-datasets",
    "title": "Practice on your own",
    "section": "The datasets",
    "text": "The datasets\n\n🌽 🌱 The Plant Scientist #1: maize plants infected with the fungus Ustilago maydis\n\nExperiment ID: E-CURD-40\nExperimental factors:\n\ntreatment, with levels: Ustilago maydis and none\ntimepoint, with levels: 0.5, 1, 2, 4, 6, 8, 12, days after infection\n\n\n🌱 🧪 The Plant Scientist #2: Arabidopsis roots treated with different plant hormones\n\nExperiment ID: Deforges_2019\nExperimental factors:\n\ncondition, with levels: control, auxin, aba, meja or acc.\n\n\n🧠 ⚡ The Neuroscientist: different brain regions from patients with different psychiatric problems\n\nExperiment ID: E-GEOD-78936\nExperimental factors:\n\ndisease, with levels: normal, schizophrenia, bipolar disorder\nbrain_region, with levels: area 9, area 11, area 24\n\n\n🦠 🔬 The microbiologist: Pseudomonas aeruginosa bacteria exposed to different concentrations of copper\n\nExperiment ID: GSE160187\nExperimental factors:\n\ngenotype, with levels: POA1 (wild-type bacteria) and XEN41 (tetracyclin resistant bacteria)\ntreatment, with levels: none, MIC/10, MIC levels of copper\ntimepoint, with levels: 0, 24, 48, 72 hours of incubation",
    "crumbs": [
      "Practice on your own"
    ]
  }
]